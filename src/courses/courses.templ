package courses

import (
    "github.com/michalhercik/RecSIS/utils"
    "strconv"
)

const coursesPerPage = 30

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}

// TODO: do not use this, use DB, this is deprecated
func examTypeStr(examType string) string {
    // to add: STEX, thesis, ...
    switch examType {
    case "Z":
        return "C" // Z
    case "1":
        return "??" // do not know
    case "F":
        return "MC" // KZ
    case "D":
        return "??" // do not know
    case "K":
        return "Ex" // Zk
    case "*":
        return "C+Ex" // Z+Zk
    default:
        return "unknown"
    }
}

func hoursString(lecture, seminar int) string {
    return strconv.Itoa(lecture) + "/" + strconv.Itoa(seminar)
}

// TODO: use just examType
func hoursExamsString(lecture, seminar int, examType string) string {
    return hoursString(lecture, seminar) + ", " + examTypeStr(examType)
}

func semesterHoursExamsString(course *Course, t text) string {
    semCount := course.SemesterCount
    result := ""
    switch semCount {
    case 1:
        switch course.Start {
        case teachingWinterOnly:
            result = t.WinterAssign + " " + hoursExamsString(course.LectureRange1, course.SeminarRange1, course.ExamType)
        case teachingSummerOnly:
            result = t.SummerAssign + " " + hoursExamsString(course.LectureRange1, course.SeminarRange1, course.ExamType)
        case teachingBoth:
            result = t.Both + " " + hoursExamsString(course.LectureRange1, course.SeminarRange1, course.ExamType)
        default:
            result = "unsupported"
        }
    case 2:
        switch course.Start {
        // TODO: this probably wont fit, fix this
        case teachingWinterOnly:
            result = t.W + ":" + hoursString(course.LectureRange1, course.SeminarRange1) + " " + t.S + ":" + hoursString(course.LectureRange2, course.SeminarRange2) + ", " + examTypeStr(course.ExamType)
        // TODO: this probably wont fit, fix this
        case teachingSummerOnly:
            result = t.W + ":" + hoursString(course.LectureRange2, course.SeminarRange2) + " " + t.S + ":" + hoursString(course.LectureRange1, course.SeminarRange1) + ", " + examTypeStr(course.ExamType)
        case teachingBoth:
            result = "unsupported"
        default:
            result = "unsupported"
        }
    default:
        result = "unsupported"
    }
    return result
}

templ QuickResults(res *QuickResponse, t text) {
    <div
        id="quick-search-results"
        class="dropdown-menu w-100 shadow-sm show"
    >
        if res.approxHits == -1 {
            // Don't render anything if approxHits is -1
        } else if len(res.courses) == 0 {
            <div class="dropdown-item text-muted">{ t.NoCoursesFound }</div>
        } else {
            for _, course := range res.courses {
                <a
                    href={ templ.URL(t.Utils.LangLink("/course/" + course.code)) }
                    class="dropdown-item text-truncate"
                    hx-boost="false"
                >
                    { course.code + " - " + course.name }
                </a>
            }
        }
    </div>
}

templ search(coursesPage *coursesPage, t text) {
    <form
        hx-get={ t.Utils.LangLink("/courses/search") }
        hx-target="#courses"
        hx-swap="outerHTML"
        :hx-vals="generateHxVals()"
        :hx-push-url="currentUrl"
        class="pt-3 pb-3"
        x-data="{ quickResOpen: false }"
    >
        <div class="justify-content-center mx-5">
            <div class="dropdown" @click.away="quickResOpen = false">
                <div class="input-group">
                    <input type="text" name="search" id="search" class="form-control" placeholder={ t.SearchPlaceholder } autocomplete="off"
                        x-model="params.search"
                        @click="quickResOpen = true"
                        @keydown="quickResOpen = true"
                        @keydown.escape="quickResOpen = false"
                        @focus="quickResOpen = true; if (params.search !== '') $dispatch('triggerSearch')"
                        hx-get={ t.Utils.LangLink("/courses/quicksearch") }
                        hx-trigger="input changed, triggerSearch from:body"
                        hx-target="#quick-search-results"
                        hx-swap="outerHTML"
                        hx-push-url="false"
                    />
                    <button type="submit" class="btn btn-primary" @click="quickResOpen = false; params.page='1'; params.hitsPerPage='30'; updateUrl()">{ t.SearchButton }</button>
                </div>
                <div x-cloak x-show="quickResOpen && params.search.length > 0">
                    @QuickResults(&QuickResponse{
                        approxHits: -1,
                        courses: []QuickCourse{},
                    }, t)
                </div>
            </div>
        </div>
    </form>
}

templ input(id, name, inputType, value, xModel, text string) {
    <div class="form-check">
        <input role="button" class="form-check-input" type={ inputType } name={ name } id={ id }value={ value } x-model={ xModel } @change="updateUrl()" :hx-push-url="currentUrl">
        <label role="button" class="form-check-label" for={ id }>{ text }</label>
    </div>
}

templ sortInput(id, value, text string) {
    @input(id, "sort", "radio", value, "params.sort", text)
}

templ semesterInput(id, value, text string) {
    @input(id, "semester", "radio", value, "params.semester", text)
}

// TODO: fix x-model for credits
templ creditsInput(id, value string) {
    @input(id, "credits", "checkbox", value, "params.credits", value)
}

templ filterSection(coursesPage *coursesPage, t text) {
    <div class="form-group" style="height: 100%;">
        <div>
            <p class="form-label">{ t.SortByFilter + ":" }</p>
            @sortInput("sortRelevance", strconv.Itoa(int(relevance)), t.Relevance)
            @sortInput("sortRecommended", strconv.Itoa(int(recommended)), t.Recommended)
            @sortInput("sortRating", strconv.Itoa(int(rating)), t.Rating)
            @sortInput("sortMostPopular", strconv.Itoa(int(mostPopular)), t.MostPopular)
            @sortInput("sortNewest", strconv.Itoa(int(newest)), t.Newest)
        </div>
        <div>
            <p class="form-label">{ t.SemesterFilter + ":" }</p>
            @semesterInput("semesterBoth", strconv.Itoa(int(all)), t.Both)
            @semesterInput("semesterWinter", strconv.Itoa(int(winter)), t.Winter)
            @semesterInput("semesterSummer", strconv.Itoa(int(summer)), t.Summer)
        </div>
        <div>
            <p class="form-label">{ t.CreditsFilter + ":" }</p>
            for i := 0; i <= 10; i++ {
                @creditsInput("credits" + strconv.Itoa(i), strconv.Itoa(i))
            }
        </div>
        <div class="text-center justify-content-center d-flex mt-3" style="position: sticky; top: 72px;">
            <p
                role="button"
                @click="window.scrollTo({ top: 0, behavior: 'smooth' })"
                class="link-primary"
            >
                <i class="bi bi-chevron-up"></i>
                { t.TopFilter }
            </p>
        </div>
    </div>
}

templ ribbon(ba AssignmentSlice, t text) {
    if len(ba) > 0 {
        <div class="ribbon">
            <span>{ ba.String(t.Language) }</span>
        </div>
    }
}

templ blueprintAssignment(code string, t text) {
    <div class="d-flex justify-content-end mt-auto pt-3">
        <div class="btn-group">
            <button type="button" class="btn btn-blueprint"
                hx-post={ "/blueprint/course/" + code }
                hx-vals={ `"year": 0, "semester": 0, "lang": "` + t.Language + `"` }
            >
                { t.Assign }
            </button>
            <button type="button" class="btn btn-outline-blueprint dropdown-toggle dropdown-toggle-split"
                data-bs-toggle="dropdown" aria-expanded="false">
            </button>
            <ul class="dropdown-menu">
            // TODO: make dynamic, NOT 3 fixed years
                for year := 1; year <= 3; year++ {
                    <li class="mx-3"><button class="dropdown-item text-center"
                        hx-post={ "/blueprint/course/" + code }
                        hx-vals={ `"year": ` + strconv.Itoa(year) + `, "semester": 1, "lang": "` + t.Language + `"` }
                    >
                    { t.YearStr(year) + " " + t.WinterAssign }
                    </button></li>
                    <li class="mx-3"><button class="dropdown-item text-center"
                        hx-post={ "/blueprint/course/" + code }
                        hx-vals={ `"year": ` + strconv.Itoa(year) + `, "semester": 2, "lang": "` + t.Language + `"` }
                    >
                    { t.YearStr(year) + " " + t.SummerAssign }
                    </button></li>
                }
            </ul>
        </div>
    </div>
}

templ courseCard(course *Course, t text) {
    <div
        class="card custom-card rounded-0"
        x-data="{ expanded: false, showButton: false, isHovered: false }"
        @mouseenter="isHovered = true"
        @mouseleave="isHovered = false"
        x-init="$nextTick(() => { showButton = $refs.annotation.scrollHeight > 350 })"
    >
        <div class="card-header d-flex justify-content-between align-items-center">
            <h6 class="mb-0">{ course.Code }</h6>
            <small>{ semesterHoursExamsString(course, t) }</small>
            <small>{ t.Credits + ": " + strconv.Itoa(course.Credits) }</small>
        </div>
        <div class="card-body d-flex flex-column position-relative">
            @ribbon(course.BlueprintAssignments, t)
            <div
                :class="{ 'expanded': expanded, 'annotation-container': showButton }" :style="isHovered && { 'z-index': '100' }"
                x-ref="annotation"
            >
                <h5 class="card-title"><a class="link-body-emphasis link-offset-2 link-underline-opacity-0 link-underline-opacity-75-hover" href={ templ.URL(t.Utils.LangLink("/course/" + course.Code)) }>{ course.Name }</a></h5>
                <h6 class="card-subtitle mb-2 text-muted">{ course.Guarantors.string() }</h6>
                <p class="card-text annotation-text">{ course.Annotation.string() }</p>
            </div>
            <button class="btn btn-link text-secondary" @click="expanded = !expanded" x-show="showButton" x-text={ "expanded ? '" + t.ReadLess + "' : '" + t.ReadMore + "'" }></button>
            @blueprintAssignment(course.Code, t)
        </div>
    </div>
}

templ paginationIconButton(page int, icon string, cp *coursesPage, t text) {
    <li class="page-item">
        <div
            role="button"
            class="page-link"
            :class={ strconv.FormatBool(cp.page == page || page < 1 || page > cp.totalPages) + " && 'disabled'" }
            hx-get={ t.Utils.LangLink("/courses/search") }
            hx-target="#courses"
            hx-swap="outerHTML show:window:top"
            hx-trigger="new-page-event"
            @click={ "newPage('" + strconv.Itoa(page) + "', $event)" }
        >
            <i class={ icon }></i>
        </div>
    </li>
}

templ paginationNumberButton(page int, cp *coursesPage, t text) {
    <li class="page-item">
        <div
            role="button"
            class="page-link"
            :class={ strconv.FormatBool(cp.page == page) + " && 'active'" }
            hx-get={ t.Utils.LangLink("/courses/search") }
            hx-target="#courses"
            hx-swap="outerHTML show:window:top"
            hx-trigger="new-page-event"
            @click={ "newPage('" + strconv.Itoa(page) + "', $event)" }
        >
            { strconv.Itoa(page) }
        </div>
    </li>
}

templ loadMoreButton(newPageSize int, cp *coursesPage, t text) {
    <button
        class="btn btn-outline-primary"
        hx-get={ t.Utils.LangLink("/courses/search") }
        hx-target="#courses"
        hx-swap="outerHTML"
        hx-trigger="load-more-event"
        @click={ "loadMore('" + strconv.Itoa(newPageSize) + "', $event);" }
    >
        { t.LoadMore }
    </button>
}

templ threeDots() {
    <li class="page-item">
        <div class="page-link">
            <i class="bi bi-three-dots"></i>
        </div>
    </li>
}

templ pagination(cp *coursesPage, t text) {
    // disable pagination if loaded more courses
    if cp.pageSize == coursesPerPage {
        <div class="mt-3 d-flex justify-content-center">
            <ul class="pagination justify-content-center mt-3">
                @paginationIconButton(cp.page - 1, "bi bi-chevron-left", cp, t)
                @paginationNumberButton(1, cp, t)
                if cp.page > 4 {
                    @threeDots()
                }
                for i := max(2, cp.page - 2); i <= min(cp.page + 2, cp.totalPages - 1); i++ {
                    @paginationNumberButton(i, cp, t)
                }
                if cp.page < cp.totalPages - 3 {
                    @threeDots()
                }
                @paginationNumberButton(cp.totalPages, cp, t)
                @paginationIconButton(cp.page + 1, "bi bi-chevron-right", cp, t)
            </ul>
        </div>
    }
    // disable load more button if it is not the first page
    if cp.page == 1 {
        <div class="d-flex justify-content-center mt-3">
            @loadMoreButton(cp.pageSize + coursesPerPage, cp, t)
        </div>
    }
}

templ Courses(cp *coursesPage, t text) {
    <div id="courses">
        <div class="grid-cards">
            if cp.totalPages == 0 {
                <p>{ t.NoCoursesFound }</p>
            } else {
                for _, course := range cp.courses {
                    @courseCard(&course, t)
                }
            }
            // dummy cards for alignment
            for i := 0; i < 10; i++ {
                <div class="card custom-card border-0"></div>
            }
        </div>
        if cp.totalPages > 1 {
            @pagination(cp, t)
        }
    </div>
}

templ Content(coursesPage *coursesPage, t text) {
    // x-data is needed for x-bind:class
    <div id="courses-page" class="grid-page" x-data="urlParams">
        <div class="filter bg-body-secondary">
            @filterSection(coursesPage, t)
        </div>
        <div class="main-content">
            @search(coursesPage, t)
            @Courses(coursesPage, t)
        </div>
    </div>

    <script>
    // Reinitialize Alpine when HTMX swaps in new content
    document.addEventListener('htmx:afterSwap', (event) => {
        if (event.detail.target === document.body) {
            console.log("htmx:afterSwap.body");
            let initAlpine = new Event('alpine:init');
            document.dispatchEvent(initAlpine);
        }
    });

    document.addEventListener('alpine:init', () => {
        Alpine.data('urlParams', () => ({
            // Default values
            defaults: {
                search: "",
                sort: "0",
                semester: "0",
                credits: [],
                page: "1",
                hitsPerPage: "30"
            },
            params: {},
            currentUrl: window.location.href,

            init() {
                // Parse URL parameters and initialize state
                const urlSearchParams = new URLSearchParams(window.location.search);
                for (const key in this.defaults) {
                    let value = urlSearchParams.get(key);
                    if (key === "credits") {
                        this.params[key] = value ? value.split(',') : this.defaults[key];
                    }
                    else {
                        this.params[key] = urlSearchParams.get(key) ?? this.defaults[key];
                    }
                }
                this.updateUrl(); // Ensure URL is correct on load
            },

            updateUrl() {
                const newParams = new URLSearchParams();

                // Only keep parameters that differ from default
                for (const key in this.params) {
                    let value = this.params[key];
                    if (key === "credits") {
                        if (value.length > 0) {
                            newParams.set(key, value);
                        }
                    }
                    else {
                        if (value !== this.defaults[key]) {
                            newParams.set(key, value);
                        }
                    }

                }

                const newUrl = `${window.location.pathname}${newParams.toString() ? '?' + newParams.toString() : ''}`;
                this.currentUrl = newUrl;
            },

            newPage(page, e) {
                // set new page parameter
                this.params.page = page;
                // update URL with the new parameter
                this.updateUrl();
                // update pagination button hx-vals/hx-push-url before sending the request
                e.target.setAttribute('hx-vals', this.generateHxVals())
                e.target.setAttribute('hx-push-url', this.currentUrl);

                // send the request
                this.$dispatch('new-page-event');
            },

            loadMore(newPageSize, e) {
                // set new hitsPerPage parameter
                this.params.hitsPerPage = newPageSize;
                // update URL with the new parameter
                this.updateUrl();
                // update load more button hx-vals/hx-push-url before sending the request
                e.target.setAttribute('hx-vals', this.generateHxVals())
                e.target.setAttribute('hx-push-url', this.currentUrl);

                // send the request
                this.$dispatch('load-more-event');
            },

            generateHxVals() {
                // Generate the JSON object for hx-vals - only non-default parameters
                const nonDefaultParams = {};
                for (const key in this.params) {
                    if (this.params[key] !== this.defaults[key]) {
                        nonDefaultParams[key] = this.params[key];
                    }
                }
                return JSON.stringify(nonDefaultParams);
            }
        }));
    });
    </script>
}

templ Page(coursesPage *coursesPage, t text) {
    @utils.Page(t.Utils.Courses, t.Utils) {
        @Content(coursesPage, t)
    }
}