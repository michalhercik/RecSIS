package degreeplandetail

templ scripts() {
	<script>
		setupCheckboxShiftClick();
		updateStickyOffset();
		initializeTooltips();
		cleanupOffcanvasOnNavigation();
		initializeRequisiteGraph();

		// shift click for multiple checkboxes
		function setupCheckboxShiftClick() {
			let lastChecked = null;
			const checkboxes = document.querySelectorAll('input[type="checkbox"][name="selected-courses"]');
			checkboxes.forEach(checkbox => {
				checkbox.addEventListener('click', function (e) {
					if (lastChecked && lastChecked !== this && e.shiftKey) {
						let inBetween = false;
						checkboxes.forEach(box => {
							if (box === this || box === lastChecked) {
								inBetween = !inBetween;
							}
							else if (inBetween && box.checked !== this.checked) {
								box.checked = this.checked;
								box.dispatchEvent(new Event('change'));
							}
						});
						if (lastChecked.checked !== this.checked) {
							lastChecked.checked = this.checked;
							lastChecked.dispatchEvent(new Event('change'));
						}
					}
					lastChecked = this;
				});
			});
		}

		// pass through (shift-)click event to checkbox
		function handleCircleClick(event) {
			const checkbox = event.target.parentElement.previousElementSibling;
			if (checkbox) {
				// Create a new MouseEvent, preserving shift key and other properties
				const clickEvent = new MouseEvent('click', {
					bubbles: true,
					cancelable: true,
					shiftKey: event.shiftKey,
				});

				checkbox.dispatchEvent(clickEvent);
			}
		}

		// pass through click event to checkbox on small screens
		function handleTdClick(event) {
			const checkbox = event.target.querySelector('input[type="checkbox"][name="selected-courses"]');
			if (checkbox) {
				// Create a new MouseEvent, preserving shift key and other properties
				const clickEvent = new MouseEvent('click', {
					bubbles: true,
					cancelable: true,
					shiftKey: event.shiftKey,
				});

				checkbox.dispatchEvent(clickEvent);
			}
		}

		// Update the sticky offset for the checked-courses-menu based on the header height
		function updateStickyOffset() {
			const header = document.querySelector('header');
			const menu = document.getElementById('dp-checked-courses-menu');
			if (header && menu) {
				setTimeout(() => {
					const height = header.offsetHeight;
					menu.style.top = height + 'px';
				}, 0);
			}
		}

		// bootstrap tooltip initialization
		function initializeTooltips() {
			// Initialize new tooltips
			const tooltipTriggerList = document.querySelectorAll('[data-bs-toggle="tooltip"]')
			const tooltipList = [...tooltipTriggerList].map(tooltipTriggerEl => new bootstrap.Tooltip(tooltipTriggerEl))
		};

		// Add checked courses to BP btn can add only to the union of not yet assigned semesters of all checked courses 
		function updateCheckedCoursesMenu(semesterCount) {
			const checkedCourses = Array.from(document.querySelectorAll('input[type="checkbox"][name="selected-courses"]:checked'));
			const disabledSemesters = Array(semesterCount).fill(false);

			checkedCourses.forEach(checkbox => {
				// Get the table row
				const row = checkbox.closest('tr');
				if (!row) return;
				// Get the last td (blueprint button cell)
				const lastTd = row.querySelector('td:last-child');
				if (!lastTd) return;

				// Find the assign to unassigned button
				const plusBtn = lastTd.querySelector('button.assign-to-unassigned-btn');
				if (plusBtn && plusBtn.disabled) {
					// Mark first semester (unassigned) as disabled
					disabledSemesters[0] = true;
				}

				// Find dropdown items (semester assign buttons)
				const dropdownItems = lastTd.querySelectorAll('.dropdown-menu .dropdown-item');
				dropdownItems.forEach((item, idx) => {
					if (item.disabled) {
						// Mark this semester as disabled
						disabledSemesters[idx + 1] = true;
					}
				});
			});

			console.log('Disabled semesters:', disabledSemesters);

			// Now update the checked-courses-menu buttons
			const menu = document.getElementById('dp-checked-courses-menu');
			if (!menu) return;
			const innerDiv = menu.querySelector('div > div');
			if (!innerDiv) return;

			// Update the assign-to-unassigned button (first semester)
			const assignBtn = innerDiv.querySelector('button.assign-to-unassigned-btn');
			if (assignBtn) {
				assignBtn.disabled = disabledSemesters[0];
			}

			// Update dropdown items (other semesters)
			const dropdownItems = innerDiv.querySelectorAll('.dropdown-menu .dropdown-item');
			dropdownItems.forEach((item, idx) => {
				if (idx < disabledSemesters.length) {
					item.disabled = disabledSemesters[idx + 1];
				}
			});
		}

		// Close offcanvas before HTMX navigation and on browser back
		function cleanupOffcanvasOnNavigation() {
			document.body.addEventListener('htmx:beforeRequest', function(event) {
				const offcanvasElement = document.getElementById('dp-offcanvas-menu');
				if (offcanvasElement && offcanvasElement.classList.contains('show')) {
					const bsOffcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
					if (bsOffcanvas) {
						event.preventDefault();
						bsOffcanvas.hide();
						// Wait for the offcanvas to fully close, then trigger the request again
						offcanvasElement.addEventListener('hidden.bs.offcanvas', function() {
							htmx.trigger(event.detail.elt, 'click');
						}, { once: true });
					}
				}
			});
		}

		// Initialize the requisite graph using Cytoscape.js
		function initializeRequisiteGraph() {
			const graphContainer = document.getElementById('course-graph');
			if (!graphContainer) return;

			const graphData = buildGraphData();
			
			const cy = cytoscape({
				container: graphContainer,
				layout: {
					name: 'elk',
					elk: {
						algorithm: 'layered',
						'elk.direction': 'UP',
						'spacing.nodeNode': 100,						
						'spacing.componentComponent': 150,
						'spacing.nodeNodeBetweenLayers': 30,
						'spacing.edgeEdgeBetweenLayers': 20,
						'spacing.edgeNodeBetweenLayers': 30,
						'layering.strategy': 'LONGEST_PATH',
						'crossingMinimization.semiInteractive': true
					}
				},
				elements: graphData,
				style: [
					{
						selector: 'node',
						style: {
							'label': 'data(label)',
							'text-valign': 'center',
							'text-halign': 'center',
							'background-color': '#4f86f7',
							'color': '#000',
							'text-wrap': 'wrap',
							'text-max-width': 120,
							'font-size': 10
						}
					},
					{
						selector: 'node[inPlan="false"]',
						style: {
							'background-color': '#bbb',
							'border-style': 'dashed',
							'border-width': 2,
							'border-color': '#666'
						}
					},
					{
						selector: 'edge[type="prerequisite"]',
						style: {
							'line-color': '#1f77b4',
							'target-arrow-color': '#1f77b4',
							'target-arrow-shape': 'triangle',
							'curve-style': 'bezier'
						}
					},
					{
						selector: 'edge[type="corequisite"]',
						style: {
							'line-color': '#2ca02c',
							'target-arrow-color': '#2ca02c',
							'target-arrow-shape': 'triangle',
							'curve-style': 'straight'
						}
					},
					{
						selector: 'edge[type="incompatibility"]',
						style: {
							'line-color': '#d62728',
							'target-arrow-color': '#d62728',
							'target-arrow-shape': 'triangle',
							'width': 4,
							'curve-style': 'bezier'
						}
					}
				],
			});

			// Fit the graph to the canvas after layout completes
			cy.on('layoutstop', function() {
				cy.fit(cy.elements(), 50);
			});

			// Click handler
			cy.on('tap', 'node', (evt) => {
				const code = evt.target.data('code');
				window.location.href = `/course/${code}`;
			});

			// Cursor handlers
			cy.on('mouseover', 'node', function() {
				graphContainer.style.cursor = 'pointer';
			});
			cy.on('mouseout', 'node', function() {
				graphContainer.style.cursor = 'default';
			});

			// Filter handlers
			setupGraphFilters(cy);
		}

		// Build graph data from server-side data
		function buildGraphData() {
			// This is populated from server-side data
			const dataElement = document.getElementById('graph-data');
			if (dataElement) {
				return JSON.parse(dataElement.textContent);
			}
			return { nodes: [], edges: [] };
		}

		function setupGraphFilters(cy) {
			const prereqCheckbox = document.getElementById('show-prerequisites');
			const coreqCheckbox = document.getElementById('show-corequisites');
			const incompatCheckbox = document.getElementById('show-incompatibilities');

			function applyFilters() {
				cy.edges().forEach(edge => {
					const type = edge.data('type');
					let visible = true;
					
					if (type === 'prerequisite') visible = prereqCheckbox.checked;
					if (type === 'corequisite') visible = coreqCheckbox.checked;
					if (type === 'incompatibility') visible = incompatCheckbox.checked;

					edge.style('display', visible ? 'element' : 'none');
				});

				// Hide nodes without visible edges
				cy.nodes().forEach(node => {
					const connectedEdges = node.connectedEdges();
					let hasVisibleEdges = false;
					
					connectedEdges.forEach(edge => {
						const type = edge.data('type');
						if (type === 'prerequisite' && prereqCheckbox.checked) hasVisibleEdges = true;
						if (type === 'corequisite' && coreqCheckbox.checked) hasVisibleEdges = true;
						if (type === 'incompatibility' && incompatCheckbox.checked) hasVisibleEdges = true;
					});

					node.style('display', hasVisibleEdges ? 'element' : 'none');
				});
			}

			prereqCheckbox?.addEventListener('change', applyFilters);
			coreqCheckbox?.addEventListener('change', applyFilters);
			incompatCheckbox?.addEventListener('change', applyFilters);

			applyFilters();
		}
	</script>
}